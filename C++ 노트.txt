※ 회사에 들어가면 처음에 많이 하는 것
RFP (Request For Proposer) : 제안서

컴퓨터가 처리할 작업을 묘사 -> 프로그래밍
컴퓨터가 처리할 작업을 할 때 쓰는 언어 -> 프로그래밍 언어
0과 1로 구성된 언어 -> 기계어
기계어 + 니모닉 기호(ADD, SUB, MOVE) -> 어셈블리어

※ 고급언어 종류
-> Fortran, Pascal, Basic, C#, C/C++, Java

고급언어로 작성된 프로그램 -> 컴파일러
고급 -> 기계어 변환 -> 컴파일
절차대로 일련의 명령어 나열하여 프로그래밍하는 방법 -> 절차 지향 프로그래밍

Ⅰ. C++설계 목적
호환성(문법체계유지), 객체 지향 개념{캡슐화(데이터를 캡슐로 싸서 외부 접근으로부터 데이터 보호(public,private)), 상속, 다형성}, 타입 체크, 효율성 저하 최소화


Ⅱ. 추가 기능
· 함수 중복: 서로 다른 동일 이름의 함수 선언
· 디폴트 매개 변수: 매개 변수 전달이 안될 경우 디폴트 값 전달
· 참조: 변수에 별명을 붙여 변수 공간 같이 사용 가능
· 참조에 의한 호출: 함수 호출 시 참조 전달 가능
· new와 delete 연산자: 동적 메모리 할당, 해제 도입
· 연산자 재정의: 기존 연산자에 새로운 연산 정의 가능
· 제네릭 함수와 클래스: 함수나 클래스를 데이터 타입에 의존하지 않고 일반화시킴.

제네릭 프로그래밍
-> 동일한 프로그램 코드에 다양한 데이터 타입 적용할 수 있도록 함수와 클래스를 일반화시킴.		ex) 템플릿

Ⅲ. C++ 프로그램 개발 과정
소스 프로그램 작성 -> 소스 파일(.CPP) -> 컴파일 -> 목적 파일(.obj) -> 링킹 -> 실행 파일(.exe) -> 실행 -> 출력
								↑									↓
							 디버깅				<-				     오류
링킹 -> C++ 표준 라이브러리나 다른 파일 속에 있는 함수, 객체, 데이터를 포함한 모든 기계어 코드로 하나의 실행 파일로 만드는 과정
디버깅 -> 프로그램 내에 오류 위치 발견 또는 문제원인을 찾아 수정하는 과정


Ⅳ. C++ 표준 라이브러리
	ⅰ) C 라이브러리: 기존 C 표준 라이브러리를 수용해 C++에서 사용할 수 있게 한 함수들, 헤더 파일에 선언됨.	EX) ctime, ctype, cstdio, cstring 등
	ⅱ) C++ 입출력 라이브러리: 콘솔 및 파일 입출력을 위한 함수와 클래스들, 템플릿으로 작성. 	EX) ios, ostream 등
	ⅲ) C++ STL 라이브러리: 템플릿으로 작성된 함수와 클래스를 포함한 라이브러리		EX) list, stack, string, vector, set, map, memory 등


Ⅴ. std::
-> C++ 표준에서 정한 표준 이름 공간, 접두어 역할로 쓰이나 using 지시어로 생략 가능 		
	EX) using std::cout; 또는 using namespace std;
-> std::cout (출력), std::cin (입력)
-> >>연산자로 나열 가능	ex) cin >> width >> height 또는 cout >> width >> "와" >> height


Ⅵ. C++ 문자열
	ⅰ) C- 스트링: C 언어에서 문자열을 표현하는 방법	ex) strcpy(), strcmp(), strlen() -> #include <cstring> 또는 #include <string.h> 필요
		- 매개 변수로 입력하는 문자열의 경우 "마 이 클"로 입력했을 때 공백을 만나면 입력된 문자들을 하나의 문자열로 인식하기 때문에 "마"만 출력됨.
		- 위 문제를 해결하기 위해 cin.getline(char buf[], int size, char delemitChar) 함수 사용 -> 키보드로부터 주소읽기
	ⅱ) string 클래스: 문자열을 객체로 다루는 방법 (권장)

※ include <헤더 파일> 과 #include "헤더 파일" 의 차이
include <헤더 파일> : 컴파일러가 설치된 폴더에서 '헤더 파일' 찾으라는 지시
#include "헤더 파일" : 개발자의 프로젝트 폴더나 개발자가 컴파일 옵션으로 지정한 include폴더에서 '헤더 파일' 찾도록 지시


Ⅴ. C++ 클래스
클래스 구현부 => 클래스::멤버 함수명 또는 매개 변수
접근 제어 : public(클래스 내외 모든 함수 접근 허용) 과 private(클래스 내의 멤버 함수 접근 허용, 디폴트 접근 제어) 과 protected(클래스 내 + 상속받은 파생 클래스에만 접근 허용)
	ⅰ. 생성자 (★ 꼭 있어야 함!)
		- 하나의 생성자는 기본 생성자(= 디폴트 생성자)라고 함.
		- 객체 생성 시 필요한 초기작업
		- 오직 한번만 실행
		- 클래스 이름과 동일 작성
		- 원형에 리턴 타입 선언 X
		- 생성자 중복 가능
		- 생성자가 다른 생성자 호출 => 위임 생성자와 타겟 생성자
			ex) 클래스 circle(int r)로 선언된 생성자(타겟 생성자)가 초기 생성자(위임 생성자)를 적은 경우 곧 circle(int r)이 초기 생성자가 됨.
		- 멤버 변수 초기화 circle(int x, int y) {x =a; y = b;}

	ⅱ.  소멸자
		- 객체 소멸 시 메모리 반환(마무리 작업)
		- ~ 클래스 이름
		- 리턴 타입과 값 리턴 X
		- 오직 한개만 존재, 매개 변수 X
		- 소멸자 선언 안해도 기본 소멸자 자동 생성
		- 소멸자 실행은 생성된 반대순으로 소멸.

	ⅲ. 인라인 함수
		-짧은 코드로 구성된 함수의 함수 호출 오버헤드(오버헤드 ↑ -> 실행 시간 ↑)로 인한 프로그램의 실행 속도 저하를 막기 위한 기능 
			ex) inline int odd(int x) {return x%2;}
		-장점: getter/setter라는 작은 멤버 함수들에 쓰일 수 있어 프로그램 실행 속도 향상됨.
		-단점: 호출이 여러 군데이면 전체 크기가 늘어남. (∴ 가능한 작은 함수에 쓰이는게 좋음.)

	ⅳ. 구조체
		- 표준 C 구조체에 기능 확장한 클래스와 동일한 구조와 기능, struct 키워드로 선언.
		※ 클래스와 구조체의 차이점: 모든 성능은 동일하나, 디폴트 접근 지정이 클래스는 private, 구조체는 public이다.

	ⅴ) 바람직한 C++ 프로그램 작성법
		- 헤더 파일을 중복 include할 때 오류가 발생하므로 조건 컴파일 문을 삽입. 	
			ex) 헤더파일 위에 #ifndef (대문자)헤더파일이름_H, #define (대문자)헤더파일이름_H
		

Ⅵ. 객체 포인터와 객체 배열, 객체의 동적 생성
circle *p; -> 객체 포인터
p = &donut; ->  객체 주소 지정

※ 포인터를 이용한 객체 멤버 접근
d = donut.getArea(); || d = p->getArea(); || d = (*p).getArea();

ⅰ. 객체 포인터와 객체 배열
	- 객체 배열 선언문은 기본 생성자 호출
	- 객체 배열은 화살표(->)가 아닌 점(.) 연산자 사용.
	- 배열 소멸의 경우 각 원소 객체마다 소멸자 호출 (배열이 3개 있다면, 2 -> 1 -> 0 순으로 소멸)
	- 다차원 객체 배열 가능

ⅱ. 동적 메모리 할당 및 반환
C -> malloc() / free()
C++ -> new {데이터 힙(heap) -> 메모리 할당} / delete (메모리 -> 힙으로 반환)
	- 기본 활용 : 데이터타입 *포인터변수 = new 데이터타입; delete 포인터변수;
	- 동적 할당 메모리 초기화 : 데이터타입 *포인터변수 = new 데이터타입(초깃값);
※ 단, delete는 메모리 반환할 때 적절치 못한 포인터 사용하면 동적 할당받지 않는 메모리를 반환하여 실행 오류 발생함.

	- 배열 동적 할당/반환 기본 형식 : 데이터타입 *포인터변수 = new 데이터타입 [배열크기]; delete [] 포인터변수;
※ 단, 배열 동적 할당할 때 생성자를 통해 직접 초깃값 지정 불가

ⅲ. 객체와 객체 배열의 동적 생성 및 반환
- new를 이용한 객체 동적 생성과 생성자
	-> 클래스이름 *포인터변수 = new 클래스이름; // 기본 생성자 호출
	또는 -> 클래스이름 *포인터변수 = new 클래스이름(생성자매개변수리스트); // 매개 변수 있는 생성자 호출
- 객체 배열의 동적 생성과 생산자 : 클래스이름 *포인터변수 = new 클래스이름 [배열크기];
- 배열 반환과 소멸자 : delete [] 포인터변수;

ⅳ. this 포인터 (객체 자신에 대한 포인터, 클래스의 멤버 함수 내에서만 사용)
※ this가 꼭 필요한 경우
	1.  circle(int radius) { this->radius (멤버 radius) = radius (매개 변수 radius); } 
	2. 객체의 멤버 함수에서 객체 자신의 주소를 리턴할 때 (주로 연산자 중복 구현할 때 많이 씀.)
※제약 조건
	- this는 클래스의 멤버 함수에서만 사용 가능
	- 정적(static) 멤버 함수는 this 사용 x
-this는 어느 헤더 파일에 include 하고 있지 않고 묵시적으로 멤버 함수를 선언할 때 매개 변수 sample* this와 함께 선언되어 있다.

ⅴ. string 클래스를 이용한 문자열 사용
	- string 객체 생성 : #include <string>
	- 문자열 연결 : append(), 문자열 삽입 : insert(), 문자열 길이 : length()와 size(), capacity() (-> string 객체의 내부 메모리 용량 리턴 함수)
	- 문자열 삭제 : erase() (->문자열의 일부분 삭제)와 clear() (-> 완전삭제)
	- 서브스트링 : substr() (-> 문자열의 일부분 발췌), 문자열 검색 : find()
	- 각 문자 다루기 : at() 과 [] 연산자 -> 둘 다 문자열의 특정 위치에 있는 문자 리턴, at()과 달리 []연산자는 특정 문자를 다른 문자로 수정 가능
	- 문자열의 숫자 변환 : stoi()
	- getline() -> 공백 문자를 포함하는 문자열을 입력 받을 수 있음.


Ⅶ. 함수와 참조, 복사 생성자
ⅰ. 함수의 인자 전달 방식 리뷰
값에 의한 호출 -> 실인자 값이 매개 변수에 복사되어 전달되는 방식, 실인자 손상 x, 생성자와 소멸자가 있을 때 값에 의한 호출을 쓰는 경우, 생성자는 실행되지 않고 소멸자만 실행된다. (비대칭)
주소에 의한 호출 -> 주소를 직접 포인터 타입의 매개 변수에 전달받는 방식, 함수 내에서 실인자의 값 변경할 때 씀, 원본 객체의 복사시간 소모 x, 생성자 소멸자의 비대칭 문제 해결
참조에 의한 호출 -> 참조 매개 변수로 이룬 모든 연산은 원본 객체에 대한 연산임, 참조 매개 변수는 이름만 생성되므로, 생성자와 소멸자 실행 x

ⅱ. 객체 치환 및 객체 리턴
클래스 c1, c2(30)이 있을 때, c1 = c2로 선언 시 c1과 c2가 하나의 객체가 아닌 별개이며 내용물만 같음.

ⅲ. 참조(&)와 함수
int n =2; int &ref = n; -> ref = n
circle circle; circle &ref = circle -> ref = circle
refn = 3; n = 5;	 // refn = n = 5
refn++	 // refn = n = 6

※ 참조 선언 시 주의사항
- 초기화가 없으면 컴파일 오류 발생
- 참조자 &의 위치 무관		ex) int &refn = n;		int & refn = n;	int& refn = n;
- & int refn = n;		int refn & = n;	은 잘못된 참조 변수 선언
- 배열 만들 수 없음.
- 참조 변수에 대한 참조 선언 가능

※ 참조 리턴 (변수 등과 같이 현존하는 공간에 대한 참조 리턴)
☆ 포인터와 참조의 차이점?
-> 참조는 말 그대로 "별명"이라는 공간을 가지므로 함수 또한 공간을 가져 L-value에 삽입될 수 있으나 포인터는 주소를 가르키기만 하기 때문에 공간을 차지하지 않는다!
L-value -> 공간, R-value -> 값 또는 주소 값

ⅳ. 복사 생성자 (객체의 복사 생성 시에 호출되는 특별 원형의 생성자, 매개 변수는 클래스에 대한 참조 타입)
	- 복사 생성자 없는 클래스의 경우, 컴파일러가 디폴트 복사 생성자를 자동 삽입해 디폴트 복사 생성자는 얕은 복사를 실행
	- 클래스에 포인터 멤버 변수가 있는 경우, 원본과 사본 객체 공유 문제가 생기고 비정상 종료되기도 하므로 깊은 복사 생성자를 반드시 작성해야함.

※ 묵시적 복사 생성
1. 객체로 초기화하여 객체가 생성될 때
2. 값에 의한 호출로 객체가 전달될 때
3. 함수가 객체를 리턴할 때



Ⅷ. 힘수 중복과 static 멤버
ⅰ. 함수 중복
	※ 조건
	- 중복 함수 이름 동일
	- 중복 함수 매개 변수 타입 or 개수 달라야함.
	- 리턴 타입 고려 x
- 생성자 함수 중복 가능, but 소멸자는 무조건 하나만 존재

ⅱ. 디폴트 매개 변수
	- 매개변수 = 디폴트 값 	ex) void star(int a =5);
	- 디폴트 매개 변수는 모두 끝 쪽에 몰려 선언되야 함. 		
		ex) void calc(int a, int b = 0, int c, int d=0);은 컴파일 오류, c도 디폴트 설정을 해줘야 함.
	- 매개 함수를 호출할 때 컴파일러는 실인자 값들을 앞에서부터 순서대로 전달되도록 함.
	- 디폴트 매개 변수를 가진 함수는 같은 이름의 중복 함수들과 함께 선언 x

ⅲ. 함수 중복의 모호성 (형 변환, 참조 매개 변수, 디폴트 매개 변수)
	1. 형 변환 모호성
		ex) float square(float a); double square(double a); square(3); 이라고 하면 무슨 타입으로 할지 모름.
		고친다면 square((float)3)이라고 하면 오류가 안남. -> 강제 형 변환
	2. 참조 매개 변수 모호성
		ex) int add(int a, int b); int add(int a, int& b); add(s,t) 이라고 하면 함수 호출을 뭘로 할지 모름.
	3. 디폴트 매개 변수 모호성
		ex) void msg(int id); void msg(int id, string s = " "); 이라고 하면 2번과 똑같음.

ⅳ. static 멤버 <---> 인스턴스 멤버 (객체 생성 시 객체 내 메모리 공간 할당)
- static 멤버 변수는 외부 전역 변수로 선언되어야 함! 안하면 링크 오류
- 클래스 이름으로 접근 : 클래스명::static 멤버
- 가능하면 static 선언을 전역 변수 or 함수에 하지 말고 클래스에 선언하여 "캡슐화" 해주면 좋음.

※ static 특성
- 생명 주기 : 프로그램 시작할 때 생성, 종료할 때 소멸 (객체 외부에 메모리 공간 할당)
- 사용 범위 : 변수나 함수가 선언된 범위 내에 사용, 전역 혹은 지역으로 구분

※ static 멤버 함수 특징
- static 멤버 함수는 오직 static 멤버들만 접근, but non-static 멤버 함수는 static 멤버 접근하는데 제약 x
- static 멤버 함수는 this 사용 x



Ⅸ. 프렌드와 연산자 중복
ⅰ. C++ 프랜드 개념
- 프랜드 함수 개수 제한 x, 클래스 내에 선언, 클래스의 모든 멤버에 접근 가능, 클래스 외부에 작성된 함수 (멤버x)
- friend 함수 : 클래스 내에 friend 키워드로 선언된 외부 함수
- friend 함수를 선언하기 전에 반드시 전역 변수에 클래스를 선언해야 한다. ( ∵ 전방 참조 방지)

※ 선언할 수 있는 경우
	- 클래스 외부에 작성된 함수를 프랜드로 선언
	- 다른 클래스의 멤버 함수를 프랜드로 선언
	- 다른 클래스의 모든 멤버 함수를 프랜드로 선언

※ 전방 참조 : 선언되지 않은 이름이 뒤에 선언되는 이름을 미리 참조하는 경우

ⅱ. 연산자 중복
※ 특징
- C++언어 본래 있는 연산자만 중복 가능
- 피연산자의 타입이 다른 연산을 새로 정의함.
- 함수를 통해 이룸. ( = 연산자 함수)
- 반드시 클래스와 관계를 가짐. 	ex) Circle donut;	donut = donut + 3;	-> 새로운 연산자의 피연산자 중 하나는 반드시 클래스 타입이여야 함.
- 피연산자의 개수 바꾸기 x
- 연산의 우선순위 바꾸기 x
- 모든 연산자가 중복 가능한 것은 아님.


ⅲ. 이항 연산자 중복
+연산자 중복 -> 클래스 내에 operator+ (클래스명 변수) 선언 : 두 개의 클래스 객체 더함
+연산자 확장 : b = a + 2	ex) Power a(3,5), b (b는 초기화된 상태); b = a + 2;로 선언하면 b가 (0,0)에서 (5,7)로 저장됨. 
==연산자 중복 -> operator== (클래스명 변수) : 두 개의 클래스 객체를 비교
+=연산자 중복 -> operator+=(클래스명 변수) :  두 개의 클래스 객체를 더하고 더함.	ex) Power a(3,5), b(4, 6), c; c = a+= b;로 선언 하면 c(7,11)이 되면서 a도 a(7,11)이 되버림.

ⅳ. 단항 연산자 중복
전위 ++ 연산자 중복 	ex) Power a(3,5), b; b = ++a;로 선언하면 a와 b 둘 다 (4,6)으로 출력됨.
후위 ++ 연산자 중복	ex) Power a(3,5), b; b = a++;로 선언하면 a(4,6), b(3,5)로 출력됨.
참조 리턴 : << 연산자 활용	ex) Power a(1,2); a << 3 << 5 << 6;로 선언하면 a에 각각 3, 5, 6 차례대로 더하면서 a(15,16)으로 출력됨.


Ⅹ. 상속
※ 장점
	- 클래스 간의 계층적 분류 및 관리의 용이함
	- 클래스 재사용과 확장을 통한 SW의 생산성 향상
	
ⅰ. 클래스 상속과 객체
상속 선언 : class 클래스명 : 접근 제어 클래스명{}
객체 생성 : 클래스명 객체;	파생 클래스명 객체;
private : 부모 클래스의 멤버 변수로 선언하면, 기존 클래스 내의 함수에게만 쓸 수 있고, 파생 클래스는 못 씀, but 구현할 때 파생 클래스 안에 부모 클래스 함수를 넣는다면 그 함수안에 부모 클래스의 멤버 변수가 접근이 가능함.

ⅱ. 상속과 객체 포인터
	1. 업 캐스팅(up-casting) : 파생 클래스 객체 -> 부모 클래스의 포인터로 가리키는 것.
		ex) 부모 클래스 포인터 = 파생 클래스
		- 부모 클래스의 멤버만 접근 가능
		- 명시적 타입 변환 필요 x
	2. 다운 캐스팅(down-casting) : 객체 -> 파생 클래스 포인터로 가리키는 것.
		- 강제 타입 변환 필요
		ex) 부모 클래스 포인터 = (부모 클래스 포인터)파생 클래스 객체
	
ⅲ. protected 접근 지정
private : 멤버 선언 클래스 접근 가능, but 파생 클래스나 다른 클래스나 외부 함수에 접근 불가
protected : 멤버 선언 클래스 및 파생클래스 접근 가능, but 다른 클래스나 외부 함수 접근 불가
public : 모든 클래스 및 외부 함수에 접근 가능


ⅳ. 상속과 생성자, 소멸자
	※ 파생 클래스와 기본 클래스의 생성자 호출 및 실행 관계
		- 파생 클래스 객체 생성시 파생 클래스 생성자 및 기본 클래스 생성자 모두 실행됨.
		- 기본 클래스 생성자가 먼저 실행됨.
		- 묵시적으로 기본 클래스의 기본 생성자가 호출 됨. ( ∴ 파생 클래스 생성자는 선언되어 있어도 기본 클래스 생성자가 선언되지 않는다면 컴파일 오류가 난다.)

ⅴ. 상속의 종류 : public, protected, private 상속
public 상속 : 기본 클래스의 protected, private 멤버들은 접근 지정 변경 없이 그대로 파생 클래스에 상속 확장됨.
protected 상속 : 기본 클래스의 protected, private 멤버들 -> protected 접근 지정으로 변경
private 상속 : 기본 클래스의 protected, private 멤버들 -> private 접근 지정으로 변경
※ 상속 접근 지정자를 생략하면 디폴트 접근 제어는 private로 됨.

ⅵ. 다중 상속 : 하나의 파생 클래스가 여러 클래스를 동시 상속받는 것
※ 선언 : 파생 클래스명 : 기존 클래스명1, 기존 클래스명2{}
※ 한계점 : 다중 상속을 받는 클래스 2개가 또 다른 클래스에 서로 상속받는다면 액세스 모호성으로 인해 컴파일 오류 발생 
	ex) class Base{int mode;}; class In : public Base{}; class Out : public Base{};	class Inout : public In, public Out;	Inout 객체;	객체.mode = 5;
		라고 선언하면 mode변수가 In의 mode인지, Out의 mode인지 모름. (중복 상속)

ⅶ. 가상 상속
- 다중 상속의 한계점을 해결하기 위해 만듦, virtual 키워드를 이용하여 이미 공간을 할당받은 기본 클래스의 멤버에 대한 공간 할당하지 않도록 하는 지시.
※ 선언 : 파생 클래스명 : virtual 기존 클래스명{}



ⅩⅠ. 가상 함수와 추상 클래스
ⅰ. 상속 관계에서의 함수 재정의
정적 바인딩 : 파생 클래스에서 기본 클래스의 함수호출하고, 파생 클래스의 포인터는 파생 클래스에 작성된 함수를 호출	(범위 지정 연산자(::)로도 접근 가능)

ⅱ. 가상 함수(virtual function)와 오버라이딩(overriding)
오버라이딩 : 파생 클래스에서 기본 클래스에 작성된 가상 함수 재작성 -> 기본 클래스에 작성된 가상함수 무력화하고 객체의 주인 노릇을 하는 것. (∴ 기본 클래스의 가상 함수 재정의)
가상 함수 : virtual 키워드로, 컴파일러에게 자신에 대한 호출 바인딩을 실행 시간까지 미루도록 지시하는 키워드.

※ 오버라이딩 목적
- 파생 클래스들이 자신의 목적에 맞게 가상 함수 재정의
- 기본 클래스의 가상함수는 파생클래스에서 구현해야 할 일종의 함수 인터페이스 제공 -> 객체 지향 언어의 다형성 실현


★ 동적 바인딩 (= 실행 시간 바인딩, 늦은 바인딩) : 가상 함수 호출 시 실행 중에 객체 내에 오버라이딩된 가상 함수를 동적으로 찾아 호출
	- 오버라이딩된 함수 무조건 호출
	- 파생 클래스의 객체 내에, 기본 클래스의 포인터로 가상 함수가 호출될 때 일어남.
	※ 동적 바인딩 발생하는 경우
		- 기본 클래스 내 멤버 함수가 가상 함수 호출
		- 파생 클래스 내 멤버 함수가 가상 함수 호출
		- main() 같은 외부 함수에서 기본 클래스의 포인터로 가상 함수 호출
		- 다른 클래스에서 가상 함수 호출

★ override 지시어와 final 지시어
override : 컴파일러에게 오버라이딩 확인하도록 지시, 파생 클래스의 오버라이딩하려는 가상 함수의 원형 바로 뒤에 작성.
final : 파생 클래스에서 오버라이딩 x 하거나 클래스 상속 자체 금지시킴.
	ex1) 기본 클래스 안에 선언된 가상 함수 뒤에 선언	-> 파생 클래스는 기본 클래스의 가상 함수를 오버라이딩 할 수 없음.
	ex2) 클래스 이름 바로 뒤에 선언	-> 다른 클래스는 그 클래스를 상속 못함.

※ C++ 오버라이딩 특징
	- 오버라이딩의 성공과 실패 : 기본 클래스 안에 가상 함수와 파생 클래스의 안에 가상 함수의 이름이 틀리면 컴파일 오류가 나도록 함.
	- 오버라이딩 시 virtual 생략 가능 : 기본 클래스 안에 가상 함수를 선언하면 파생 클래스의 안에 똑같은 가상 함수를 선언할 때 virtual 키워드를 생략해도 됨.
	- 가상 함수 접근 지정

※ 오버라이딩과 범위 지정 연산자(::)
	- 가상 함수에 의해 무시된 기본 클래스의 가상 함수는 범위 지정 연산자(::)을 통해서 접근 가능함. -> 정적 바인딩
	- 클래스의 멤버 함수에서도 범위 지정 연산자 이용하여 기본 클래스 가상 함수 호출가능
	※ 범위 지정 연산자
		- 전역 변수와 지역 변수의 이름이 같을 경우 :: 연산자를 통해 구분 가능
			ex) int n = 11; int main(){ int n = 3; cout << ::n << n;}하면 11, 3이 나옴,
		- 클래스의 멤버 함수와 외부 함수 이름이 같은 경우

★ 가상 소멸자
- 소멸자를 가상 함수로 선언하지 않은 경우 : 기본 클래스의 소멸자만 실행되고 파생 클래스 소멸자 실행 x
- 소멸자를 가상 함수로 선언한 경우 : 기본 클래스 소멸자 호출 -> 파생 클래스 소멸자 실행 (동적 바인딩) -> 기본 클래스 소멸자 실행

=> ★★결론 : 가상 함수 소멸자는 파생 클래스와 기본 클래스 소멸자 모두 실행됨.
※ 오버로딩 : 매개 변수 타입이나 개수가 다른 함수들을 여러 개 중복 작성한 것.

ⅲ. 추상 클래스 (abstract class)
- 순수 가상 함수 (pure virtual function) : 함수 코드 x 선언만 있는 가상 함수.
	ex) virtual void draw() = 0;
- 추상 클래스는 불완전한 클래스 ( ∴ 추상 클래스의 인스턴스(객체) 생성 x), but 추상 클래스에 대한 포인터는 선언 가능
- 구현하려면 상속받은 추상 클래스의 모든 순수 가상 함수를 오버라이딩하여 구현해야 함.
※ 목적
	- 상속을 위한 기본 클래스
	- 파생 클래스가 구현할 함수의 원형을 보여주는 인터페이스 역할



★★★★ ⅩⅡ. 템플릿과 표준 템플릿 라이브러리(STL)
ⅰ. 일반화와 템플릿
	※ 함수 중복의 약점 : swap(int& a, int& b); 와 swap(double& a, double& b);의 경우 다른 타입도 똑같이 swap함수와 구현해야하므로 코드 길이가 길어지고 알고리즘 수정 시 중복된 모든 함수들의 코드를 수정해야됨.

☆ 템플릿 : "형판", 함수나 클래스 코드를 생산할 수 있도록 일반화시키는 도구
	-> template 키워드 사용(-> 템플릿 함수 or 제네릭 함수)
☆ 제네릭 타입 : C++의 기본 타입이 아님, 일반화시킨 새로운 타입(->일반 타입)
※ 구체화 : 중복 함수들을 템플릿화하는 과정의 역과정

★★ 템플릿 역할 : 제네릭 함수 선언하고 컴파일 시점에 구체화시키기 위한 틀 만들기, but 서로 다른 타입의 매개 변수를 템플릿 class T에 넣으면 오류가 난다.
※ 장단점
	- 함수 작성 용이, 함수코드 재사용 가능 	-> SW의 생산성과 유연성 ↑
	- 포팅에 취약하고, 오류 메시지가 빈약 	-> 디버깅의 많은 어려움이 있음.


ⅱ. 다양한 제네릭 함수 만들기
	1. 하나의 제네릭 타입 가진 경우 
		- 두 개의 매개 변수로부터 큰 값 구하기 : template <class T> T bigger(T a, T b);
		- 배열의 합 구하기 : template <class T> T add(T data[], int n);
	2. 두 개 이상의 제네릭 타입을 가진 경우
		- 배열 복사하기 : template <class T1, class T2> void mcopy(T1 src[], T2 dest [], int n);
	※ 중복 함수가 템플릿 함수보다 우선하여 바인딩함!

	3. 템플릿 함수에 디폴트 매개 변수 사용		
		- template <class T1, class T2> void mcopy(T1 src[], T2 dest [], int n = 5);


ⅲ. 제네릭 클래스 만들기
※ 제네릭 클래스 선언 : 클래스 선언부와 구현부 모두 template로 선언.
	- 선언부 : template <class T> class 클래스명 {};
	- 구현부 : template <class T> void 클래스명<T>:: 함수명 {}
		
	1. 두개 이상의 제네릭 타입을 가진 제네릭 클래스
		- template <class T1, class T2, class T3>


ⅳ. C++ 표준 템플릿 라이브러리(STL)와 활용
☆ 표준 템플릿 라이브러리(STL) : 템플릿으로 작성된 많은 제네릭 클래스와 함수 라이브러리
	1. 컨테이너(container) - 템플릿 클래스 : 데이터 저장 및 검색을 위해 담아두는 자료구조 클래스
		ex) 리스트, 큐, 스택, 맵, 셋, 벡터
	☆ 컨테이너 종류
		- 순차 컨테이너(Sequence Container) : 연속적인 메모리 공간에 순서대로 값을 저정하고 읽는 컨테이너, 특정 위치에 있는 값 읽거나 변경 가능	ex) vector list, dequeue
		- 컨테이너 어댑터(Container Adaptor) : 다른 컨테이너를 상속받아 기능 중 일부 공개하여 기능 제한하거나 변형한 컨테이너	ex) stack, queue
		- 연관 컨테이너(Associative Container) : '키'로 '값'을 저장, '키'로 검색하여 '값'을 알아내는 컨테이너	ex) set, map
	2. iterator(반복자) - 컨테이너 원소에 대한 포인터 : 컨테이너 원소 하나씩 순회접근을 위해 만든 컨테이너 원소에 대한 포인터.
	3. 알고리즘 - 템플릿 함수 : 복사, 검색, 삭제, 정렬 등의 기능을 구현한 템플릿 함수.

※ vector 컨테이너 활용		#include <vector>
vector - 가변 길이 배열 구현한 제네릭 클래스, []연산자로 작성되어 있음, 벡터의 원소에 대한 인덱스는 0부터 시작함.
vector 객체 생성 : vector<int> v;
vector 원소 삽입 : v.push_back(1);
vector 원소 값 읽기 및 변경 : v.at(1); (읽기), v[2] = 5; (변경)
vector 원소 개수 알기 : v.size()
vector 원소 삭제 : vector<int>::iterator it;		it = v.begin();	it = v.erase(it);	-> 벡터 v의 첫 번째 원소 삭제

※ iterator 사용	#include <vector>
iterator : 컨테이너 안의 원소들 하나씩 순차접근을 위한 원소에 대한 포인터
iterator 객체 생성 : vector<int>::iterator it;
iterator 원소 값 읽기 및 쓰기 : int n = *it; (읽기),	*it = 5; (쓰기)
※ v.end -> 마지막 원소 다음 위치에 대한 포인터를 it에 저장한다.

※ map 컨테이너 활용 #include <map>
map : '키'와 '값'의 쌍을 원소로 저장하고 '키'를 이용하여 값을 검색하는 제네릭 컨테이너. 	
map 컨테이너 생성 및 원소 삽입 : map<string, string> dic;		// 키는 영어단어, 값은 한글 단어
원소 저장 : dic.insert(make_pair("love","사랑"));		dic["love"] = "사랑";
'키'로 검색하여 '값' 알아내기 : string kor = dic["love"];
'키'데이터 있는지 검사하기 : if(dic.find(eng) == dic.end())

※ STL 알고리즘(-> 전역함수) 활용 	#include <algorithm>
sort(시작 iterator 주소, 마지막 iterator 주소)
for_each(v.begin(), v.end(), print) -> print()를 v의 원소 개수만큼 호출하여 각 원소 검색

ⅳ. auto와 람다식
※ auto 선언식 : auto 변수 = 3.14;
- 타입 자동 결정으로, 코드 수정에 따른 오류 가능성 낮추는 효과가 있음.

※ 람다식 = 이름 없는 익명 함수
	※ 캡처 리스트 요소
		[x] -> 변수 x의 값 활용		[&x] -> 참조변수 x 활용	[=] -> 모든 변수 값 활용	[&] -> 모든 참조 변수 활용
- [](int x, int y) {cout << "합은 " << x + y; } (2,3);
- auto calc = [pi](int r) -> double {return pi *r * r;}
- [&sum](int x, int y) {sum = x + y;}(2,3);	-> 캡처리스트 참조 활용

★★ C++의 람다식 의미 : 간단하고 짧게 최적화돈 코드 작성에 좋음, 람다가 유용한 경우
	- 한 번만 호출, 재사용 x 때문에 함수에 이름을 붙일 필요 없는 경우
	- STL 알고리즘 함수의 매개 변수에 연산 코드 넘기는 경우, 연산 코드를 익명의 람다식으로 작성.



 ⅩⅢ. C++입출력 시스템
스트림(Stream) : 흐르는 시냇물
입력 스트림 : 입력 장치로부터 입력된 데이터를 순서대로 프로그램에 전달하는 객체
출력 스트림 : 출력 데이터를 목적 장치의 순서대로 보내는 객체
※ 표준 C++은 스트림 입출력만 다룸!
※ iostream -> istream + osteam

※ 조작자 특징
	- 출력코드를 간결하게 만듦, 조작자의 사용을 권함.
	- 포맷은 한 번의 입출력에만 적용하므로 입출력마다 포맷을 지정해야함.

삽입 연산자 = << 연산자		-> 정수를 비트 단위로 시프트 하는 연산자, 다양한 값도 출력할 수 있음
추출 연산자 = >> 연산자 		-> 키 입력 또는 파일 읽을 때 사용
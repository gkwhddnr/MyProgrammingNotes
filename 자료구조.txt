Ⅰ. 자료구조 및 알고리즘
	알고리즘: 특정 일을 수행하는 명령어들의 유한 집합
	자료구조: 문제해결을 위해 필요한 데이터 조직화
	프로그램: 컴퓨터 언어를 사용한 알고리즘 구현

	※ 좋은 알고리즘: 수행시간 ↓, 메모리 공간 ↓수록 좋음
		평가기준: 공간복잡도(필요한 메모리 공간) => 고정 공간{문제의 인스턴스(입출력 크기)에 무관한 일정 양의 메모리 공간} + 가변 공간(instance에 따른 가변적 메모리 공간), 시간복잡도 (수행시간)

ex) 공간 복잡도 분석
float sum(float list[], int n) {
float temsum = 0
int i = 0;
for (i=0;i<n;i++)
	temsum += list[i]
return temsum
}
고정공간: i, n, temsum
가변공간: list[] (배열 or 포인터) ex) float list[]로 선언하면 float 변수는 4byte이지만 배열 가변 변수이므로 8byte.
총 공간의 양: 2* sizeof(int) + sizeof(float) + ?

※ 시간 복잡도 분석
- 실험적 수행시간 측정 -> 사용하지 않음
- 수행되는 문장들의 스텝 수 계산 및 측정
	1. s/e(steps/execution) : 각 문장에 대한 스텝 수
	2. Frequency : 각 문장이 실행되는 빈도 
	3. 각 문장에 대한 총 스텝 수 : s/e * frequency

ex) 시간 복잡도 분석 				s/e	frequency	total steps
float sum(float list[], int n) { 			0	0		0
float temsum = 0					1	1		1
int i;							0	0		0
for (i=0;i<n;i++)					1	n+1		n+1
	temsum += list[i]				1	n		n
return temsum					1	1		1
}
							total			2n+3

ex2)
void add(int a[], [m_size]...){			0	0		0
	int i, j;					0	0		0
	for(i =0;i < m;i++)			1	m+1		m+1
		for(j = 0; j<n; j++)		1	m*(n+1)	m*n + m
			c[i][j] = a[i][j] + b[i][j]	1	m*n		m*n
}	
							total			2mn+2m+1

ex3)
sum = 0						1
int i = 1						1
while int i <= n					log2 n + 1
	sum += sum + i				1		=> 2 (while문 안에 실행되는 횟수) * log2 n씩 반복 => 2^k ≤ n
	i = i * 2					1
total							f(n) = 2log2 n + log2 n + 1 = 3log2 n + 1 =>O(log2 n)

- 단계 수 대신 수학적 기호 사용 
	ex) Big-oh(O, 상한) = f(n) = 3n + 2라 하고 f(n) ≤ c * g(n)을 만족하는 c & n 값이 존재함.
(이때, g(n)는 f(n)의 최고차항의 계수로 가정)
※ 오메가(하한)는 기호가 반대임!

(문제) n명의 학생(학번) 가정 -> 특정 학생(학번)을 찾음.
※ 분석 방법
1. 단순 방법 -> 평균 수행시간 : O(n)
2. 개선 -> 학번을 "오름차" 순 정렬
3. Hash (반으로 계속 쪼개서 메모리 할당 최소화시킴)
=> 데이터가 n에서 n/2씩 감소됨. -> 학번이 1개가 남을 때까지 (n/2^k = 1)
∴ n = 2^k => k = log2 n = O(n)	(k는 반복횟수)


Ⅱ. 희소행렬의 전치행렬의 계산
희소행렬 -> 2차원 배열인데, 예를 들어 36개의 메모리를 먹는 배열 중에 7개 공간만 사용하는 행렬.
전치행렬 -> 2차원 행렬에서 행과 열의 값이 서로 바뀐 행렬.

※ 자료구조 설계
- 단순 2차원 배열 사용
- 메모리 공간 많이 차지
- 행과 열의 값만 바꾸어 구현이 쉬움.
- 메모리 공간을 사용하기 위해 0이 아닌 항만 저장(k)
- (행, 열, 값)의 쌍을 사용한 배열 구조 정의

※ 효율성 분석
- 희소 행렬, K = 0 이 아닌 항수
- 수행시간 : O(n*k) -> 줄일 수 있는 방법? -> 나의 생각(idea), 행의 개수 정보를 미리 알 수 있도록!
- 수행공간 : O(k)

★★★ 결론
	1. 수행공간 & 수행시간 고려 x 단순 알고리즘 설계 : O(n^2)
	2. 수행공간 고려 but 수행시간 x : O(n * k)
	3. 수행시간과 수행공간 모두 고려 : O(n + k)

Ⅲ. 다항식의 덧셈 계산
※ 자료구조 설계
- 다항식의 계수가 0이 아닌 항을 (계수, 차수)의 쌍으로 표현
- 구조체 배열로 정의

※ 구조체 배열에서 덧셈 과정
두 다항식 차수 동일 -> 두 다항식 계수 합을 avail 위치에 저장 및 인덱스 증가
두 다항식 차수 다름 -> 차수가 큰 쪽의 계수를 avail 위치에 저장 및 인덱스 증가


Ⅳ. 연결리스트의 기초 연산 ★★★ 
date - 노드에 들어갈 자료
link - 다음 노드의 포인터
★★ 연결리스트 특징
- 자료크기 제한 x
- 동적 메모리 공간 관리
- 삽입/삭제 응용 문제 해결 적합

ⅰ. 연결리스트 생성
수행시간 및 공간(입력값 개수가 n일 경우)  : O(1), O(n)

ⅱ. p번째 노드 생성
※ 알고리즘 : p번째 node 찾음 -> 다음 삽입 -> 데이터 삽입 -> 포인터 변경
- p번째 노드에 새 Node 삽입할 때 (입력 값의 개수 = n일때)
	수행시간 : O(n)
	수행공간 : O(n)

ⅲ. 노드 삭제
※ 알고리즘 : 주어진 값과 일치하는 node 검색 -> 포인터 변경 (이전 노드 기억) -> 노드 제거
수행시간 및 공간(입력값 개수가 n일 경우)  : O(1), O(n)

★★ 결론
- 동적 메모리 할당으로 자료 크기 영향 x
- 특정 노드 삽입/삭제 용이
- 삽입/삭제 시에 데이터 이동 필요
- 포인터의 변경 필요


Ⅴ. 연결리스트의 역 리스트 구성
date - 노드에 들어갈 자료
link - 다음 노드의 포인터
p -> 30, q -> 20, r -> 10/Null에서 p -> Null, q -> 30, r -> 20 -> 10/Null
=> p-> Null, q -> Null, r -> 30 -> 20 -> 10/Null


Ⅵ. 원형 연결리스트에서 노드의 삽입
★ 원형 연결리스트 (마지막 노드의 링크 포인터 -> 첫번째 노드를 가리킴) ⇔ 단순 연결리스트 (마지막 노드 링크 Null)

ⅰ. 헤더 포인터가 리스트의 첫번째 노드를 가리킬 경우
※ 알고리즘 : 새로운 node (맨 앞에 삽입) -> Head를 첫 Node를 가리킴.
※ 구현 : 마지막 Node 찾음 (CurrentNode가 Head와 같을 때까지) -> 새 Node 할당 -> 포인터 변경
- 수행시간 (입력 노드수 = n일때) : O(n)

ⅱ. 헤더 포인터가 리스트의 마지막 노드를 가리킬 경우
※ 알고리즘 : Head를 마지막 Node를 가리킴 -> new_node를 Head로 -> Head_node를 new_node로 가리킴.
- 수행시간 (입력 노드수 = n일때) : O(1)

★★ⅰ과 ⅱ의 차이점
=>	수행공간은 모두 동일, but ⅱ의 방법으로 수행시간을 O(1)로 줄임!


Ⅶ. 오름차순을 갖는 두 리스트의 합병 
- 수행시간?		=> O(n+m)
a -> 연결리스트 node 수 : m
b -> 연결리스트 node 수 : n

★★ 결론
1. 오름차순으로 정렬된 두 개의 연결 리스트가 주어진 경우
	- 입력으로 주어진 두 리스트 원형 유지
	- 두 리스트 합병하여 새로운 연결리스트 구성
2. 수행시간 및 공간
	- 수행시간은 두 리스트의 크기에 비례
	- 수행공간은 두 리스트의 합의 크기에 비례


Ⅷ. 배열 스택의 기본 연산과 배열 스택을 사용한 수식 계산
스택(stack) : 삽입 / 삭제 연산이 한쪽 끝에서 이루는 자료구조(LIFO)
top 인덱스 : 자료 삽입 / 삭제를 이룬 인덱스 변수
삽입(push) : top++, 삭제(pop) : top--
함수 : empty, full, push, pop 필요
수행시간 : 삽입(push) / 삭제(pop) 함수 	=>	둘 다 O(1)

※ stack 사용 수식 계산
	1. 중위식 -> 후위식 변환
	2. 후위식 -> 계산
		ex) 입력 중위식 : 2 + 3 * 5 - 4 /2
			변환된 후위식 : 2 3 5 * + 4 2 / -

· stack 연산자 비교 (프로젝트 (5.2) pdf 참고)
	- {우선순위 높음 -> push, 낮음 -> pop }-> 반복
	- 왼쪽 괄호 : "(" -> push, 오른쪽 괄호 : stack에서 왼쪽괄호가 나올때까지 pop.
· 수행시간? 	->	중위식 길이에 비례-> O(len)

★★ 결론
	- 중위식 -> 후위식 변환하고 변환된 후위식 계산	
	- 수행시간 : 중위식 또는 후위식 길이에 비례
	- 수행공간 : 중위식 또는 후위식 길이에 비례


Ⅸ. 배열 큐의 기초 연산 
· 큐(queue) : 데이터 삽입/삭제가 다른 위치에서 일어나는 자료구조(FIFO)
· 기본연산 : 삽입(rear) /삭제(front)
· 6개의 배열이 있을 때, 단순배열의 경우 0 1 2 3은 비어있고 4 5에 데이터가 있는 문제가 발생할 수 있음. -> 원형 큐 사용	-> 6번째를 0번째로 가리킨다. (rear = (rear + 1) % queue_size), front도 똑같음.
· queue_empty -> 큐가 비어있는지 검사, queue_full, queue_enqueue (삽입), queue_dequeue (삭제)
※ queue_size가 n개일 때, 최대 보관 data 수는 n-1개임!
☆ 수행시간 : O(1), 수행공간은 큐 배열 크기에 비례!
※ 장단점
	- 구현이 매우 단순
	- 정적 메모리 공간 사용에 가변적 크기 발생 	->	연결리스트 큐를 구현!



Ⅹ. 큐를 사용한 전위식의 계산
	전위식 : 연산자가 피연자보다 앞쪽에 위치
	전위식 스캔 -> 토큰 값이 피연산자의 경우, 큐에 삽입
	-> 토큰 값이 연산자
		1. 연산자 다음 두 개 토큰이 모두 피연산자 -> 피연산자에 연산자를 취해 계산한 값을 큐에 삽입
		2. 그렇지 않으면 토큰을 큐에 삽입



ⅩⅠ. 배열을 사용한 완전이진트리 표현 
- 행의 단위 : level
	- 일반 트리 : 별로 사용안함.
	- 이진트리 : 많아봐야 2개의 자식 노드 존재, 주로 많이 씀. (1, 2번만 배움.)
		1. 포화이진트리 : 각 레벨에서 자식 노드가 모두 채워진 이진트리
		2. 완전이진트리 : 자식 노드가 왼쪽부터 순서대로 채워진 이진트리	// 1,2번은 배열구조에 적합
		3. 이진트리			// 연결리스트에 적합
		4. 이진탐색트리		// Heap 트리

※ 부모 ↔ 자식 노드 관계 ( i = 0부터 시작한다고 가정, h는 부모자식을 제외한 자식 행 level 개수)
- index i의 왼쪽 자식 : i * 2
- index i의 오른쪽 자식 : i * 2 + 1
- index i의 부모 노드 : i / 2
- level i에서 node 개수 : 2^(i-1)
- 높이가 h일 경우 전체 node 개수 : 2^0 + 2 ^1 + 2^2 + ... + 2^(h-1) = 2^h - 1개
- 전체 노드 수 = n일 경우 h는?	2^h-1 = n 		=>	h = log2 (n+1)
★★ 수행시간 : O(log2 n)에 비례! (트리의 높이에 비례)



ⅩⅡ. 완전이진트리를 사용한 힙 트리의 구성
최대 힙(max heap) 트리 : 완전이진트리로 구성, 부모 노드 키 값 >= 자식 노드 키 값, 왼쪽 오른쪽 자식 크기 구분 x
최소 힙(min heap) 트리 : ", 부모 노드 키 값 <= 자식 노드 키 값,  ".	   10	
※ 힙 응용 : 우선순위 큐, 프린터 스풀러						  /
	ex) 20,30,10,55,65,70 을 순서적으로 입력 : 20 - 30 -> 30 - 20 -> 30 - 20 -> ...
☆ 수행시간 : O(log n)



ⅩⅢ. 연결리스트를 사용한 이진트리 표현
※ 이진트리의 한계점은 h= 5일 때 메모리는 2^5 - 1 = 31개를 차지하는데 메모리가 비어 있는 부분도 있음. -> 불필요한 메모리 할당	->	연결리스트 활용!
node.left_child, node_right_child : 왼쪽/오른쪽 자식 노드
Preorder_traversal : 전위순회
Inorder_traversal : 중위순회
Postorder_traversal : 후위순회
☆ 수행시간 : O(n),	수행공간 : O(n)
★★★ 결론 : 완전이진트리 -> 배열에 적합, 이진트리 -> 연걸리스트에 적합












Ⅰ. 이진탐색트리의 연산 및 관리
이진탐색트리(Binart Search Tree : BST) : 유일한 키 값을 가짐, "왼쪽 서브트리의 모든 노드의 키 값 < 노드의 키 값 < 오른쪽 서브 트리의 모든 노드의 키 값" 을 충족

※ 사용 목적
- 검색(탐색) 속도 개선
- 수행시간 O(n) -> O(log2 n)으로 줄임. (수행시간은 트리 높이에 비례)
- 높이 : log n ≤ h ≤ n

※ 해결과제
1. 이진탐색트리에서 가장 작은 값을 찾음.
2. 가장 큰 값을 찾음.
3. 주어진 키 값 탐색.
4. 새로운 키 값 삽입
5. 주어진 키 값 삭제

☆ BST가 좋은 성능을 발휘하기 위해서
=> 높이 균형을 유지해야됨! (균형 유지 알고리즘 : LR, RC LL, RR (4가지 알고리즘은 배우진 않음))



Ⅱ. 그래프 자료구조 및 탐색 알고리즘 
※ 그래프 : 정점과 간선(edge)으로 구성
- 무방향 그래프 : 간선 방향없는 그래프
- 방향 그래프 : 간선 방향있는 그래프

※ 정점 i의 차수?		->	i번째 행 또는 열의 합
※ 방향 그래프 정점 i의 진입차수(In-degree) -> 열의 합
※ 방향 그래프 정점 i의 진출차수(Out-degree) -> 행의 합

- 깊이우선탐색(DFS: Depth First Search) 방법 -> 재귀, Stack
- 너비우선탐색(BFS: Bread First Search) 방법 -> 재귀, queue

※ 수행시간 
- 인접행렬: 최소 O(n^2)
- 인접리스트 : O(노드 수 + 간선 수)



Ⅲ. 그래프 연결 확인 및 연결 요소
목적 : 주어진 Graph에 연결된 서브 그래프 찾고 연결되어 있는지 확인
응용 : 컴퓨터 네트워크 망 관리
그래프 연결확인 및 요소 수 계산 : 그래프 탐색 방법 중 DFS 탐색 사용, 인접리스트 사용
※ 그래프는 cycle이 존재!

※ 신장 트리 (Minimum Spanning tree) : 각 정점의 연결방식을 다양하게 표현

수행시간 : 정점개수 n, 간선개수 e라 가정 => O(n + e)



Ⅳ. 그래프의 최소비용 신장트리의 구성
★ 최소비용 신장트리(MST, Minimum Spanning Tree) : 가중치 그래프가 주어지면 간선들의 비용 합이 최소가 되는 신장 트리
	- Prim 방법 (최소 수행시간 : O(n^2), 알고리즘 수행시간 : O(n^3)), kruskal 방법, Sollin 방법
	※ Prim과 kruskal은 Greedy 방법을 쓴다. but 그럼에도 불구하고 최적해를 보장함.
	※ 그래프와 트리 차이점 : 사이클 구성 여부
	※ MST 조건
		- 그래프에 존재하는 모든 정점 포함
		- MST에 포함되는 간선 가중치 합 최소
		- 신장트리의 두 정점 경로가 존재
	응용 : 컴퓨터 네트워크 망 관리 최적화
	- 가중치 그래프 : 인접행렬로 표현

(문제) 지수함수 	->	완전한 해 찾지 않고 근시해를 찾음	(경험적인 방법(Hewistic Method), AI 접근 방법, ★★ Greedy 방법 (현재 상태에서 먹기 좋은 놈(= 최선의 방법)을 선택하는 방법, 최적해를 보장하지 않을 수 있음!))

※ 과제 선택 시 Prim 방법과 kuskal 방법을 비교한 내용을 작성할 것! ( + unim-find연산)


★ kruskal 알고리즘
- 가중치 값을 오름차순 (quick(퀵) 정렬 사용, O(elog e))으로 정렬
- 순서적 연결,  Cycle 발생 (어떻게 찾을 것이냐?	-> unim-find 연산)하면 무시
- (n - 1)개 edge가 구성될 때가지 반복 	-> O(n)

unim-find 연산 ex) {0}, {1}, {2}, {3}, {4}, {5}
unim(0,1)	->		0 - 1
unim(2,3)	->		2 - 3
unim(4,5)	->		4 - 5
unim(0,2)	->		0 - 1
				└ 2 - 3
unim(1,3)하면 1과 3을 연결해야하는데 cycle 발생한다. 이를 볼려면
★ find 연산	find(1) = 0, find(3) = 0		=> 둘다 같을 경우 cycle 발생!
unim(1,5)하면	find(1) = 0, find(5) = 4		=> cycle이 발생하지 않음!, 1과 5를 연결

ex2) 일반적인 상황이면
	unim(i, j),	find(i), find(j) 	=> find(i) == find(j) 	->	cycle발생 	->	else "No cycle"



Ⅴ. 그래프에서 최단 경로를 찾는 문제
※ Shortest path problem
	- All-Source-All-Destinatim : Floyd 알고리즘 (안 배움)
	- Single-Source-All-Destinatim : Dijkstra 알고리즘 (이 내용만 다룸)

★ Dijkstra 알고리즘 : Graph 모델링, 가중치 그래프 -> 인접행렬 표현 -> "idea"

※ 개념정의
v : 시작 정점,	u : 끝 정점,		distance[u] : 정점v에서 u까지 최소 비용
u -> k로 연결	=>	distance[k]
★ 이때 정점 u와 k의 거리? 	=>	weight[k,u] (가중치값)
∴ distance[u] = min(distance[u], distance[k] + weight[k, u])		전자는 v->u의 비용, 후자는 v->k->u의 비용

★★ 가중치 그래프가 주어질 경우 최단 경로 및 비용 계산 -> 인접행렬로 표현한 Dijkstra 알고리즘 적용
※ 수행시간 : O(n^2)
※ 응용 : 컴퓨터네트워크, 자동차 네비게이션


Ⅵ. 방향 그래프에서 사이클을 찾는 문제
※ Graph 탐색 : DFS 또는 BFS
※ cycle 존재 여부 : DFS (적용과정에서 백간선 (back edge) 존재)

visited[] : 방문 여부 ( 0 or 1)
r_stack[] : 백간선 존재? (stack 개념 포함)

★ r_stack[]이 1로 이동한다?	->	백간선 존재!

방향 그래프가 주어질 경우 사이클 존재 여부 확인 ->  DFS 탐색 방법 사용, 인접리스트로 표현
★ 수행시간 : O(n + e), n : 정점의 수, e : 간선의 수



Ⅶ. 삽입정렬을 사용한 정수 값의 정렬
※ 정렬 (sorting)
- 내부정렬 : Memory (RAM) 사용		ex) 버블, 교환, 삽입, 합병, 힙, 퀵, 지수, ... 	※ 버블과 교환은 쓰지 말라!
- 외부정렬 : Memory (RAM) + 외부장치 (HDD, ...)

※ 문제해결을 위한 탐색
- 1차원 배열 사용
- 정렬을 위한 입력과 출력
	입력 : random_data[] = {정렬되지 않은 랜덤 데이터}
	출력 : random_date[] = {오름차순으로 정렬된 데이터}

Best case : 입력 list가 오름차순 정렬로 정렬된 list 	수행시간 : O(n)
시간 복잡도 : data 수 -> n개 내림차순 정렬

Worst case : 입력 list가 내림차순 정렬			수행시간 : O(n^2)

★★ 결론
- 삽입정렬은 입력 데이터 수의 제곱에 비례
- 입력 데이터 일부가 오름차순 정렬되어 있을 경우 좋은 성능 발휘
- 학생정보 관리 : 초기 학번에 따라 오름차순 정리, 이후 변동은 데이터 순서가 바뀔 경우 재정리



Ⅷ. 퀵 정렬을 사용한 정수 값의 정렬
※ 접근법 : 분할 정복(Divide & conquer) , 가장 빠른 정렬 방법
※ 정렬을 위한 입력과 출력은 삽입정렬과 동일

pivot값 = 기준값
★★ 시간복잡도 : O(n) * O(log n) = O(nlog n)
Quick_partion() : O(n)
Quick_sort() : O(log n)
가정 : 균등 분할 (n개의 리스트를 n / 2^k씩 분할)	=>	Quick_sort() : O(log n)
※ 퀵정렬이 예외적인 상황 : 입력리스트가 오름차순 정렬
가정 : pivot값 = 첫번째 리스트 값	-> 분할 불가(n번 -> n -1번 -> n -2번 -> ...)	=> 수행시간 : O(n^2)

★★ 결론
- 평균 수행시간은 O(nlog n), 가장 빠른 정렬
- 분할 정복 기법으로 문제해결, 순환적 방법으로 알고리즘 간결구현
- 리스트가 정렬되어 있을 경우 최악의 성능 발휘
- 피봇 값 선택은 수행시간에 상당 영향을 줌 (※ 과제 선택 시 피봇 값의 선택에 따른 시뮬레이션들을 작성하여 수행시간 변화를 적을 것)
- 피봇 값에 따라 분할된 리스트 크기가 달라짐.
- 피봇 값은 리스트에서 첫번째 값, 중앙값, 마지막 값 등 선택될 수 있음.



Ⅸ. 학생 정보 리스트의 순차 및 이진탐색과 해시 탐색
※ 해쉬
- 해쉬 테이블 (배열, 연결리스트)
- 해쉬 함수 (유일한 주소값을 가짐(= 충돌이 적음), 균등하게 분포, 해쉬함수의 계산이 단순/시간 적어야함)	=> 좋은 해쉬함수
- 키값 : 유일한 값		ex) 학번
=> 이 과정들에서 충돌이 발생	=> 해결: 선형조사법(1차, 2차), Chaining방법


※ 탐색 방법 : 키 값을 이용하여 주어진 리스트 탐색 (순차탐색 (O(n)), 이진탐색(O(log n)), 해싱탐색)
★★ 결론
- 순차탐색 : 단순 알고리즘, but 수행시간은 비효울적
- 이진탐색 : 순차탐색에 비해 수행시간 상당수준으로 개선
★★ (기말에 꼭 나옴) -  2차 선형 조사법 하는 방법을 알고 있을 것!

※ 해시 탐색
- 해시 함수를 사용하여 키 값에 대한 주소 값을 결정하고 리스트에서 키 값을 탐색함.

※ 시간 복잡도
알고리즘 Hash_function : (키 값의 길이 = key_len) O(key_len), 수행시간은 O(1)
알고리즘 Sinfo_create : (충돌 발생 x) O(1), (1차 선형이 최악으로 적용) O(Hash_size)

★★ 논의
- 해시 함수는 최대한 균등하게 분포, 충돌이 적어야함.
- 해시 함수 설계 방법은 제산 함수, 폴딩 함수, 중간제곱 함수, 비트 추출 함수, 숫자분석 방법 등에 사용
- 충돌 문제 해결을 위해 2차 선형 조사법, 이중 해시법, 체이닝 방법 등 있음

※ ★★★ 좋은 해시 함수?
	1. 제산 함수 
		해시 테이블 size : n
		h(k) = k % n => [0, n-1]

	2. folding 함수
		ex) key : 20241122 -> 3자리 폴딩
		shift folding : 202 | 411 | 22 -> 202 + 411 + 22 = 635 	-> 635 % n => h(k) = (합) % n
	2-1. boundary folding (경계 폴딩) : 202 + 114 + 22 => 338 % n -> h(k)

	3. 중간제곱 함수
		key :  |  |	-> 2번째 숫자묶음을 x라고 가정	->	h(key) = x^2 % n

	4. 비트추출 함수
		key  -> 2진수 변환 -> 어디서 어디까지 구간을 추출 (y라 가정) 	=>	h(key) = y % n

	5. 숫자분석 함수 : key에 중복된 pattern이 많을 경우
		ex) 20221122, 20222133, 20221523, 2024...., 2024...., ....	(뒤 4자리는 k')
			앞 4자리수(k)가 중복됨(2022, 2024).	-> 중복된 수를 제외 (k -> k')		=> h(k) = k' % n
		
※ 체이닝 방법
- 연결리스트를 사용하여 해시 관리 및 충돌 해결
- 수행시간 : O(1)

	※ 논의
		- 배열 기반의 1차 또는 2차 선형 조사법으로 충돌 문제 해결
		- 데이터 크기에 따라 해시 테이블 유연하게 관리
	
		
Ⅹ. 세그먼트 트리를 사용한 영역합 문제	(2학기 "SW 프로그램"할 때 구현할 것)
Segment tree : 부분합 	-> start부터 end까지의 부분합 추출	-> 부분합 안에 부분합을 또 추출
순차적 방법?	=>	단순합	=> O(n)
효과적 방법?	=>	세그먼트 트리 	=>	O(log n)
Trie : 검색

- 완전이진트리 or 포화이진트리에 배열을 자료구조로 활용
- 이진트리 단말 노드 개수 n, 비 단말 노드개수 n-1개로 전체 노드 개수는 2n-1개
- 배열 크기 : 2 * 2^(log n) -1
- 왼쪽 자식 노드 인덱스 : 2*i +1, 오른쪽 자식 노드 인덱스 : 2*i +2, 부모노드 인덱스 : (i-1)/2
★★ Divide & Conquer 	=>	"재귀 함수" 사용
- 세그먼트 트리 메모리 공간 : O(2^(log n))
- 입력크기 n 커질수록 빈 메모리 공간 많이 발생


ⅩⅠ. 세그먼트 트리를 사용한 영역 최소 질의 문제
※ 주어진 입력 리스트의 원소의 최소 값 갖는 세그먼트 트리 구성하는 방법
1. 질의 범위 i ~ j에 대해 list[i]에서 list[j]까지 단순 반복으로 최소 값 찾기 -> O(n)
2. list[i]에서 list[j]까지 최소 값 찾아 query[i, j]에 미리 저장 후 최소 값 찾기 -> (사전 계산시간)O(n^2), (검색시간)O(1)
3. 질의 범위 i ~ j에 대해 세그먼트 트리 사용하여 최소 값 찾기 -> O(log n)


ⅩⅡ. 트라이를 사용한 단어 관리 문제
- 주로 사전에 쓰임.
- 문자열 탐색할 때 주로 쓰임.
- 수행시간은 O(len)에 비례, 메모리 공간 : O(alpha * len * no) (alpha : 알파벳 문자수, no : 단어 수)


ⅩⅢ. 트라이를 사용한 최장 공통 전위 매칭 문제
※ 수행시간 
- 단어 집합을 트라이로 구성 : O(len * no) (len : 가장 긴 단어의 길이, no : 단어 개수)
- 최장 공통 전위 문자열 찾기 : O(len)
